### 衡量排序算法的效率

效率分析：

1. 最好情况、最坏情况、平均情况时间复杂度

   对于要排序的数据，有的接近有序，有的完全无序。有序度不同，对于排序的执行时间会有影响。所以需要知道排序算法在不用数据规模下的性能表现。

2. 时间复杂度的系数、常数、低阶

   实际开发中，待排序数据规模可能很小。所以进行算法分析时，就得把系数、常数、低阶考虑进来。

3. 比较次数和交换次数

   分析效率时，还应该把比较和交换次数考虑进来。

原地排序：

​	空间复杂度是`O(1)`的算法。

稳定性：

​	排序之后，相等元素之间原有的先后顺序不变，则为稳定。

----

### 冒泡排序

比较相邻元素，如果不满足大小关系，就互换。

分析：

- 时间复杂度为`O(1)`，是原地排序算法。

- 相同大小的数据，在排序后不会改变顺序，是稳定的排序算法。

- 最好情况时间复杂度`O(n)`，最坏情况时间复杂度`O(n^2)`，平均情况时间复杂度`O(n^2)`

- 冒泡排序交换次数等于逆序度，也就是`n*(n - 1)/2 - 初始有序度`。

----

### 插入排序

将数组分为两个区间，`已排序区间`和`未排序区间`。

初始已排序区间只有一个元素，是数组第一个元素。

取未排序区间元素，在已排序区间找到合适的插入位置，插入元素，重复这个过程。

未排序区间为空，算法结束。

分析：

- 是原地排序算法
- 是稳定的排序算法
- 最好情况时间复杂度`O(n)`，最坏情况时间复杂度`O(n^2)`，平均情况时间复杂度`O(n^2)`。
- 移动的次数是固定的，等于逆序度。

----

### 选择排序

从未排序区间选择最小的元素，放到已排序区间的末尾。

分析：

- 是原地排序算法
- 不稳定的排序算法
- 最好、最坏、平均情况时间复杂度`O(n^2)`

----

### 冒泡排序 vs 插入排序

- 冒泡排序的数据交换要比插入排序的数据移动复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。
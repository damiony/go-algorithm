# 字符串匹配算法

- `BF`算法
- `RK`算法



## 相关概念

如果说，在字符串A中查找字符串B，那字符串B就是模式串，字符串A就是主串。主串长度记为n，模式串长度记为m。



## `BF`算法

`BF`是`Brute Force`的缩写，`BF`算法叫作暴力匹配算法，也叫朴素匹配算法。

算法思想：

​	在主串中检查起始位置分别是`0,1,2...n-m`且长度为 `m`的`n-m+1`个子串，看有没有跟模式串匹配的。

时间复杂度：

​	理论上，时间复杂度为`O(n+m)`。

优势：

1. 实际开发中，主串和模式串的长度都不会太长。并且大部分情况下，算法执行效率都会高于`O(n+m)`。
2. 算法思想简单，代码实现简单，易于调试且不易出错。



## `RK`算法

`RK`算法全称叫作`Rabin-Karp`算法。

算法思想：

​	通过哈希算法对主串中的`n-m+1`个子串求哈希值，然后逐个与模式串的哈希值比较大小。

​	如果相等，且无哈希冲突产生，则子串和模式串匹配；如果相等，且有概率出现哈希冲突，则再比较子串和模式串的具体内容。

哈希算法设计：

​	如果要匹配字符串的字符集中，只包含`K`个字符，就可以用一个`K`进制数来表示一个子串，然后将`K`进制数转化为十进制数，作为哈希值。

​	子串哈希值的计算具有规律，可以根据前一个子串的求得后一个子串。

时间复杂度：

​	时间复杂度为`O(n)`，但是如果存在大量哈希冲突，时间复杂度就会退化为`O(n*m)`。



## `BM`算法

算法思想：

​	在模式串与主串匹配的过程中，当模式串与主串某个字符不匹配，跳过一些肯定不会匹配的情况，将模式串外后多移几位。

坏字符规则：

​	从模式串的末尾往前倒着匹配，当出现某个字符无法匹配时，这个字符就叫作坏字符（主串中的字符）。

​	当发生不匹配时，把坏字符对应的模式串中的字符下标记作`si`。

​	如果坏字符在模式串中存在，把坏字符在模式串中的下标记作`xi`。

​	如果坏字符在模式串多出出现，此时选择最靠后的那个，避免模式串滑动过多。

​	如果不存在，把`xi`记作-1。

​	模式串往后移动`si-xi`。

好后缀规则：




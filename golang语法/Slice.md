# Slice

### 语法

* `slice`底层引用了数组对象，一个`slice`由三个部分组成：指针、长度和容量。

* 指针指向第一个`slice`元素对应的底层数组元素地址，长度对应`slice`元素的地址，容量对应`slice`开始位置到底层数组结尾位置。

* 内置的`len`和`cap`返回`slice`的长度和容量。

* 如果切片操作超过了`cap`的上限，将导致`panic`异常。



### 创建

一个`slice`类型一般写为`[]T`，其中`T`代表`slice`中元素的类型。

- 可以使用`var`创建，得到的是`slice`的零值`nil`：

  ```go
  var s []int
  ```

- 可以通过已有`slice`或者数组创建：

  ```go
  // 引用第i个元素到第j-1个元素
  s1 := s1[i:j]
  ```

  如果`i`省略，将使用`0`代替；如果`j`省略，将使用`j-1`代替。

- 可以使用字面值语法创建：

  ```go
  // 顺序指定初始值
  s1 := []int{1, 2, 3}
  // 索引指定初始值
  s2 := []int{1: 1, 9: 9}
  // 二者混合使用
  s3 := []int{1: 1, 2, 3, 4, 9: 9}
  ```

- 可以使用`make`创建：

  ```go
  // 仅指定长度
  s1 := make([]int, 10)
  // 指定长度容量
  s2 := make([]int, 5, 10)
  ```

  

### 零值

* 一个零值的`slice`等于`nil`。

* 零值的`slice`没有底层数组，长度和容量都是0。

* 可能存在非零值的`slice`，长度和容量都是0。

* `slice`只能与`nil`比较。

* 可以通过`[]int(nil)`创建一个对应类型`slice`的`nil`值。
* `nil`值的`slice`的行为和其他任意`0`长度的`slice`一样。



### append函数

* 内置的`append`函数向`slice`追加元素。

  ```go
  var x []int
  x = append(x, 1)
  x = append(x, 2, 3)
  x = append(x, x...)
  ```

* `append`函数可能会导致底层数组内存空间的重新分配



### copy函数

- 将一个`slice`复制到另一个相同类型的`slice`，并且返回两者中的较小者。

  ```go
  copy(dst, src)
  ```

  

